---
title: "first pass at transition model"
---

```{r get_corHMM, message=FALSE}
while (require("corHMM") && packageVersion("corHMM") < "2.7.1") {
  if (!interactive()) {
    stop("need hacked version of corHMM. Try 'remotes::install_github(\"bbolker/corHMM\", build_vignettes=TRUE)'")
  }
  ## if installation fails when building vignettes drop build_vignettes=TRUE (default is FALSE)
  if (toupper(trimws(readline("Install newest version of corHMM?")))=="Y") {
    remotes::install_github("bbolker/corHMM", build_vignettes=TRUE)
  }
}
```

```{r pkgs, message=FALSE, warning=FALSE}
library(bbmle) ## for likelihood profiles/CIs
library(numDeriv) ## for Hessian/Wald CIs
library(MCMCpack) ## for Bayes (Metropolis-Hastings) run
library(coda)
library(lattice)
library(ggplot2); theme_set(theme_bw())
library(ggthemes)
library(colorspace)
library(GGally)
library(fishtree)
library(caper)
source("utils.R")
```

# loading data and tree and trimming

```{r get_data}
allData <- read.csv("data/binaryTraitData.csv", header = TRUE)
fullPhy <- fishtree_phylogeny(allData$species)
traitData <- with(allData,
                  data.frame(species, ag, care, mating, names=species))
## BMB: why do we need 'species' column _and_ 'names' column?
trimmedData <- comparative.data(fullPhy, traitData, names.col = names)
phy <- trimmedData$phy
data <- trimmedData$data
```

## default model

```{r default, eval=FALSE}
MK_3state <- corHMM(phy = phy, data = data, rate.cat = 1)
```


# getting state matrix and legend

```{r statemat}
LegendAndRateMat <- getStateMat4Dat(data)
RateMat <- LegendAndRateMat$rate.mat
getStateMat4Dat(data)
LegendAndRateMat <- getStateMat4Dat(data)
RateMat <- LegendAndRateMat$rate.mat
```


Make the gain and loss of care and sperm comp exogenous, down to 12 pars:

```{r simplify}
pars2equal <- list(c(7, 10, 20, 23), c(4, 11, 17, 24), c(2, 5, 15, 18), c(1, 8, 14, 21))
print(StateMatA_constrained <- equateStateMatPars(RateMat, pars2equal))
```

Run constrained/simplified model:

```{r simple, cache=TRUE}
MK_3state_simple <- corHMM(phy = phy, data = data, rate.cat = 1, rate.mat = StateMatA_constrained)
print(MK_3state_simple)
```


```{r wrapper}
## calls the model with necessary args
nllfun <- function(p) {
  a <- MK_3state_simple$args.list
  a$p <- p
  do.call(corHMM:::dev.corhmm, a)
}
p <- MK_3state_simple$args.list$p
num_pars <- length(MK_3state_simple$args.list$p)
```

# Compute Wald confidence intervals (standard-error based)

```{r wald, cache=TRUE}
H <- numDeriv::hessian(nllfun, p)
sds <- sqrt(diag(solve(H)))
wald.ci <- sweep(qnorm(0.975) * outer(sds, c(-1, 1)), 1, FUN = "+", STATS = p)
```

```{r adapt, cache=TRUE}
## adapt nllfun for mle2
names(p) <- parnames(nllfun) <- paste0("p",seq(num_pars))
m0 <- mle2(minuslogl=nllfun, start=p, vecpar=TRUE, lower=log(1e-9), upper=log(100), method="L-BFGS-B")
```

```{r save_info}
## for future
save("MK_3state_simple","nllfun","num_pars","p", "sds", "m0",
     "H", file="cache/MK_3state_simple.rda")
```


```{r profile, cache=TRUE}
fn <- "cache/MK_3state_constr1_profile.rds"
if (!file.exists(fn)) {
  ## std.err=0.2: smaller standard error than default (higher resolution)
  ## alpha=0.05: only compute out to 95% CI (shorter than default)
  t1 <- system.time(pp <- profile(m0,
                                  alpha=0.05,
                                  std.err=0.2,
                                  trace=TRUE))
  saveRDS(pp, file=fn)
} else {
  pp <- readRDS(fn)
}
```

```{r prof_plot,eval=FALSE}
plot(pp, show.points = TRUE)
```

```{r prof_CI}
prof.ci <- confint(pp)
```

## Bayesian

```{r bayes1}
logpostfun <- function(p, lb = log(1e-9), ub = log(1e2), range = 3) {
  prior.mean <- (lb + ub) / 2
  prior.sd <- (ub - lb) / (2 * range)
  loglik <- -1 * nllfun(p)
  log.prior <- sum(dnorm(p, mean = prior.mean, sd = prior.sd, log = TRUE))
  return(loglik + log.prior) ## product of likelihood and prior -> sum of LL and log-prior
}
fn <- "cache/MK_3state_constr1_mcmc.rds"
if (!file.exists(fn)) {
  m1 <- MCMCmetrop1R(logpostfun, p, verbose = 1000, thin=100, mcmc = 500000)
  saveRDS(m1, file = fn)
} else {
  m1 <- readRDS(fn)
}
```

```{r bayes_traceplot}
xyplot(m1, aspect="fill", layout=c(2,6))
```

```{r bayes_sum}
summary(m1)
raftery.diag(m1)
```

BMB: not seeing bimodality that Lucas saw?

```{r bayes_pairs}
pairs(as.matrix(m1), gap = 0, pch = ".")
bayes.ci <- t(apply(m1, 2, quantile, c(0.025, 0.975)))
```

Improved pairs plot

Graphing all CIs

```{r ci_plot}
modList <- list(Wald=wald.ci, profile=prof.ci, Bayes=bayes.ci)
nmod <- length(modList)
all.ci <- setNames(
  as.data.frame(do.call("rbind", modList)),
  c("lwr", "upr")
)
all.ci <- data.frame(
  rate = rep(factor(1:num_pars), nmod),
  method = rep(names(modList), each = num_pars),
  ## estimates are the same for Wald & profile; 
  est = c(rep(p, 2), colMeans(m1)),
  all.ci
)
all.ci$upr[is.na(all.ci$upr)] <- Inf ## extend NA confidence interval to limit of graph

ggplot(
  all.ci,
  aes(rate, est, ymin = lwr, ymax = upr, colour = method)
) +
  geom_pointrange(position = position_dodge(width = 0.5)) +
  scale_colour_discrete_qualitative() +
  scale_y_continuous(limits=c(-20,0), oob=scales::squish) +
  coord_flip()
## FIXME: indicate which values are truncated?
```
